import { pgTable, text, varchar, timestamp, boolean, integer, real, json, pgEnum } from "drizzle-orm/pg-core";
import { certificateTypeEnum, certificateStatusEnum, certificateOutcomeEnum, severityEnum, actionStatusEnum, extractionStatusEnum } from './base';

export const extractionTierStatusEnum = pgEnum('extraction_tier_status', [
  'success',
  'escalated',
  'skipped',
  'failed',
  'pending'
]);

export const certificates = pgTable("certificates", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  organisationId: varchar("organisation_id").notNull(),
  propertyId: varchar("property_id").notNull(),
  blockId: varchar("block_id"),
  batchId: varchar("batch_id"),
  fileName: text("file_name").notNull(),
  fileType: text("file_type").notNull(),
  fileSize: integer("file_size").notNull(),
  fileHash: text("file_hash"),
  storageKey: text("storage_key"),
  certificateType: certificateTypeEnum("certificate_type").notNull(),
  complianceStreamId: varchar("compliance_stream_id"),
  status: certificateStatusEnum("status").notNull().default('UPLOADED'),
  certificateNumber: text("certificate_number"),
  issueDate: text("issue_date"),
  expiryDate: text("expiry_date"),
  outcome: certificateOutcomeEnum("outcome"),
  uploadedById: varchar("uploaded_by_id"),
  reviewedById: varchar("reviewed_by_id"),
  reviewedAt: timestamp("reviewed_at"),
  currentVersionId: varchar("current_version_id"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  deletedAt: timestamp("deleted_at"),
});

export const extractions = pgTable("extractions", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  certificateId: varchar("certificate_id").notNull(),
  method: text("method").notNull(),
  model: text("model"),
  promptVersion: text("prompt_version"),
  rawResponse: json("raw_response"),
  extractedData: json("extracted_data"),
  confidence: real("confidence"),
  textQuality: text("text_quality"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const remedialActions = pgTable("remedial_actions", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  certificateId: varchar("certificate_id").notNull(),
  propertyId: varchar("property_id").notNull(),
  code: text("code"),
  category: text("category"),
  description: text("description").notNull(),
  location: text("location"),
  severity: severityEnum("severity").notNull(),
  status: actionStatusEnum("status").notNull().default('OPEN'),
  dueDate: text("due_date"),
  resolvedAt: timestamp("resolved_at"),
  costEstimate: text("cost_estimate"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  deletedAt: timestamp("deleted_at"),
});

export const extractionSchemas = pgTable("extraction_schemas", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  version: text("version").notNull(),
  documentType: text("document_type").notNull(),
  complianceStreamId: varchar("compliance_stream_id"),
  schemaJson: json("schema_json").notNull(),
  promptTemplate: text("prompt_template"),
  isActive: boolean("is_active").notNull().default(false),
  isDeprecated: boolean("is_deprecated").notNull().default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const extractionRuns = pgTable("extraction_runs", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  certificateId: varchar("certificate_id").notNull(),
  schemaId: varchar("schema_id"),
  modelVersion: text("model_version").notNull(),
  promptVersion: text("prompt_version").notNull(),
  schemaVersion: text("schema_version").notNull(),
  documentType: text("document_type").notNull(),
  classificationConfidence: real("classification_confidence").notNull().default(0),
  rawOutput: json("raw_output").notNull(),
  validatedOutput: json("validated_output"),
  repairedOutput: json("repaired_output"),
  normalisedOutput: json("normalised_output"),
  finalOutput: json("final_output"),
  confidence: real("confidence").notNull().default(0),
  processingTier: integer("processing_tier").notNull().default(6),
  tierName: text("tier_name"),
  processingTimeMs: integer("processing_time_ms").notNull().default(0),
  processingCost: real("processing_cost").notNull().default(0),
  validationErrors: json("validation_errors").notNull().default([]),
  validationPassed: boolean("validation_passed").notNull().default(false),
  repairAttempts: integer("repair_attempts").notNull().default(0),
  status: extractionStatusEnum("status").notNull().default('PENDING'),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const extractionTierAudits = pgTable("extraction_tier_audits", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  certificateId: varchar("certificate_id").notNull(),
  extractionRunId: varchar("extraction_run_id"),
  tier: text("tier").notNull(),
  tierOrder: integer("tier_order").notNull(),
  attemptedAt: timestamp("attempted_at").defaultNow().notNull(),
  completedAt: timestamp("completed_at"),
  processingTimeMs: integer("processing_time_ms").notNull().default(0),
  status: extractionTierStatusEnum("status").notNull().default('pending'),
  confidence: real("confidence").notNull().default(0),
  cost: real("cost").notNull().default(0),
  extractedFieldCount: integer("extracted_field_count").notNull().default(0),
  escalationReason: text("escalation_reason"),
  documentFormat: text("document_format"),
  documentClassification: text("document_classification"),
  pageCount: integer("page_count"),
  textQuality: real("text_quality"),
  qrCodesFound: json("qr_codes_found"),
  metadataExtracted: json("metadata_extracted"),
  rawOutput: json("raw_output"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const humanReviews = pgTable("human_reviews", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  extractionRunId: varchar("extraction_run_id").notNull().unique(),
  reviewerId: varchar("reviewer_id").notNull(),
  organisationId: varchar("organisation_id").notNull(),
  approvedOutput: json("approved_output").notNull(),
  fieldChanges: json("field_changes").notNull().default([]),
  addedItems: json("added_items").notNull().default([]),
  removedItems: json("removed_items").notNull().default([]),
  errorTags: text("error_tags").array(),
  wasCorrect: boolean("was_correct").notNull().default(false),
  changeCount: integer("change_count").notNull().default(0),
  reviewTimeSeconds: integer("review_time_seconds"),
  reviewerNotes: text("reviewer_notes"),
  reviewedAt: timestamp("reviewed_at").defaultNow().notNull(),
});

export const fieldConfidenceScores = pgTable("field_confidence_scores", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  extractionRunId: varchar("extraction_run_id").notNull(),
  certificateType: text("certificate_type").notNull(),
  fieldName: text("field_name").notNull(),
  confidenceScore: real("confidence_score").notNull(),
  extractedValue: text("extracted_value"),
  correctedValue: text("corrected_value"),
  wasCorrected: boolean("was_corrected").notNull().default(false),
  correctionReason: text("correction_reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const autoApprovalThresholds = pgTable("auto_approval_thresholds", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  organisationId: varchar("organisation_id"),
  certificateType: text("certificate_type").notNull(),
  fieldName: text("field_name"),
  minConfidenceThreshold: real("min_confidence_threshold").notNull().default(0.9),
  requiredSampleSize: integer("required_sample_size").notNull().default(100),
  currentSampleSize: integer("current_sample_size").notNull().default(0),
  currentAccuracy: real("current_accuracy"),
  isEnabled: boolean("is_enabled").notNull().default(false),
  lastEvaluatedAt: timestamp("last_evaluated_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const confidenceBaselines = pgTable("confidence_baselines", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  certificateType: text("certificate_type").notNull(),
  fieldName: text("field_name").notNull(),
  sampleCount: integer("sample_count").notNull().default(0),
  avgConfidence: real("avg_confidence").notNull().default(0),
  medianConfidence: real("median_confidence"),
  correctionCount: integer("correction_count").notNull().default(0),
  accuracyRate: real("accuracy_rate"),
  recommendedThreshold: real("recommended_threshold"),
  lastUpdatedAt: timestamp("last_updated_at").defaultNow().notNull(),
});

export const benchmarkSets = pgTable("benchmark_sets", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull(),
  description: text("description"),
  documentTypes: text("document_types").array(),
  isLocked: boolean("is_locked").notNull().default(false),
  itemCount: integer("item_count").notNull().default(0),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  lockedAt: timestamp("locked_at"),
});

export const benchmarkItems = pgTable("benchmark_items", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  benchmarkSetId: varchar("benchmark_set_id").notNull(),
  certificateId: varchar("certificate_id").notNull(),
  expectedOutput: json("expected_output").notNull(),
  difficulty: text("difficulty").notNull().default("medium"),
  challengeTypes: text("challenge_types").array(),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const evalRuns = pgTable("eval_runs", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  benchmarkSetId: varchar("benchmark_set_id").notNull(),
  modelVersion: text("model_version").notNull(),
  promptVersion: text("prompt_version").notNull(),
  schemaVersion: text("schema_version").notNull(),
  overallScore: real("overall_score").notNull(),
  exactMatchRate: real("exact_match_rate").notNull(),
  evidenceAccuracy: real("evidence_accuracy").notNull(),
  schemaValidRate: real("schema_valid_rate").notNull(),
  scores: json("scores").notNull(),
  itemResults: json("item_results").notNull(),
  previousRunId: varchar("previous_run_id"),
  regressions: json("regressions").notNull().default([]),
  improvements: json("improvements").notNull().default([]),
  scoreDelta: real("score_delta"),
  passedGating: boolean("passed_gating"),
  gatingNotes: text("gating_notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const certificateVersions = pgTable("certificate_versions", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  certificateId: varchar("certificate_id").notNull(),
  versionNumber: integer("version_number").notNull().default(1),
  fileName: text("file_name").notNull(),
  fileType: text("file_type").notNull(),
  fileSize: integer("file_size").notNull(),
  storageKey: text("storage_key"),
  extractedData: json("extracted_data"),
  extractionRunId: varchar("extraction_run_id"),
  uploadedById: varchar("uploaded_by_id"),
  uploadReason: text("upload_reason"),
  supersededAt: timestamp("superseded_at"),
  supersededById: varchar("superseded_by_id"),
  supersededReason: text("superseded_reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
